# 스케줄링

---

### 프로세서

- 프로세서(CPU)에 의해 처리되는 사용자/시스템 프로그램
- 프로세스의 제어 블록 PCB에 프로세스 식별자, 상태 등의 중요 정보를 저장
- 각 프로세스 실행 시 교유 PCB 생성
- 작업 완료 후 PCB 제거

  [제출]  ---->  [접수]  --Job 스케줄러-->  [준비]  <--Time--  --Dispatch-->  [실행]  ---->  [종료]

  Submit         Hold                   ^   \                               /

  .              |  ^                Wake up  \                           /  Run out

  .              v  |                           \                   v   /

  .             디스크                               대기 Wail / Block

  🚀️ Dispatch: 준비 상태에서 대기 중인 프로세스가 실행 상태로 전이되는 과정

  🚀️ Wake up: 입출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이

  🚀️ Switching(문맥 교환): 이전 프로세스의 상태 레지스터 내용을 보관하고 다음 프로세스의 레지스터를 적재하는 과정

---

### 스레드

- 단일 스레드: 하나의 프로세스에 하나의 스레드
- 다중 스레드: 하나의 프로세스에 복수의 스레드
- 동일 프로세스 환경 내 서로 다른 다중 스레드 수행 가능

  장점) 한 프로세스 내 복수의 스레드를 생성하여 작업 병행성 향상

  .    응답시간 단축 / 기억 장소 낭비 최소화 / 프로세스 간 통신 향상

  .    운영체제 성능 및 프로그램 처리 효율 향상 / 접근 가능한 기억장치 사용
- 사용자 수준

  - 사용자가 만든 라이브러리를 이용한 스레드 운용
  - 속도는 빠르나 구현이 어려움
- 커널 수준

  - 운영체제의 커널에 의한 스레드 운용
  - 구현이 쉬우나 속도가 느림

---

### 스케줄링 : 여러 프로세스의 처리 순서를 결정하는 기법

1) 선점형: 운영체제가 실행 중인 프로세서부터 CPU를 강제로 빼앗음
   ** 하나의 프로세스가 CPU를 차지하고 있을 때, 우선 순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 스케줄링 방식
   ** 비교적 응답이 빠르다는 장점이 있지만, 처리 시간을 예측하기 힘들고 높은 우선순위 프로세스들이 계속 들어오는 경우 오버헤드 초래

* Round Robin
  * 프로세스마다 같은 크기의 CPU 시간을 할당
  * 프로세스가 할당된 시간 내에 처리완료를 못하면 준비 큐 리스트의 가장 뒤로 보내지고, CPU는 대기 중인 다음 프로세스로 넘어감
  * 균등한 CPU 점유 시간을 보장하며, 시분할 시스템에 사용
* SRT Shortest Remaining Time
  * 비선점형 SJF 기법을 선점 스케줄링 형식으로 변경
  * 잔여 실행 시간이 가장 짧은 프로세스에 CPU 우선 할당
  * 남은 시간이 더 짧다고 판단되는 프로세스가 준비 큐에 생기면 언제라도 프로세스가 점령됨
* 다단계 큐
  * 프로세스를 그룹화 후 각 그룹마다 다른 준비 상태 큐를 사용
  * 상위 준비 상태의 큐에 CPU 우선 할당
  * 하위 준비 상태의 큐 실행 간 상위 준비 상태 큐 유입 시 상위 프로세서에 CPU 우선 할당
* 다단계 피드백 큐
  * 입출력 위주와 CPU 위주인 프로세스에 따라 큐마다 서로 다른 CPU 시간 할당량 부여
  * FCFS와 라운드 로빈 기법의 혼합
  * 프로세스 생성 시 가장 높은 우선 순위 준비 큐에 등록되며 등록된 프로세스는 FCFS 순서로 CPU를 할당받아 실행
  * 단계가 내려갈 수록 시간 할당량이 증가
  * 새로운 프로세스는 높은 우선순위를 가지지만 프로세스의 실행 시간이 길어질수록 점점 낮은 우선순위 큐로 이동하며, (이 때, 우선 순위가 낮을수록 시간 할당량을 크게 줌으로써 보완 가능) 마지막 단계에서 FCFS 방식을 적용
  * 유연성이 뛰어남
  * 응답 시간에 최적화

2. 비선점형: 기존 프로세서가 점유하고 있는 CPU를 빼앗을 수 없음
   ** 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법 -> 낮은 처리율
   ** 프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용하지 않음
   ** 우선순위 : 각 프로세스 별로 우선순위가 주어지고, 우선순위에 따라 CPU 할당, 우선순위가 같을 경우 FCFS 적용, 설정이나 자원 상황 등에 따른 우선순위를 선정해 주요 프로세스나 긴급 프로세스에 대한 우선 처리 가능
   ** 기한부 : 작업들이 명시된 기간이나 기한 내에 완료되도록 계획

* FCFS First Come First Serve

  - CPU를 먼저 요청한 프로세스가 먼저 CPU를 배정받는 스케줄링 방법
  - 프로세스가 대기 큐에 도착한 순서에 따라 CPU 할당 (=FIFO)
* SJF Shortest Job First

  * 프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료 시 까지 선점
  * 준비 큐 작업 중 가장 짧은 작업부터 수행하므로 평균 대기시간 최소
  * CPU 요구시간이 긴 작업과 짧은 작업 간의 불평등이 심하며, CPU 요구시간이 긴 프로세스는 기아 현상 발생
* HRN Highest Response ratio Next

  * 우선 순위를 계산하여 프로세스의 처리 순서 결정
    ** 우선 순위 = (대기시간 + 서비스 시간) / 서비스 시간
  * 실행 시간이 긴 프로세서가 불리한 SJF 기법을 보완
  * 긴 작업과 짧은 작업 간의 지나친 불평등을 해소할 수 있음
